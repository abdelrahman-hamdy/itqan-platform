<!DOCTYPE html>
<html>
<head>
    <title>LiveKit Connection Test</title>
    <script src="https://cdn.jsdelivr.net/npm/livekit-client/dist/livekit-client.umd.min.js"></script>
</head>
<body>
    <h1>LiveKit Connection Diagnostic</h1>
    <button onclick="testConnection()">Test Connection</button>
    <div id="results"></div>
    
    <script>
        async function testConnection() {
            const results = document.getElementById('results');
            results.innerHTML = '<h2>Testing...</h2>';
            
            let html = '';
            
            // Test 1: WebRTC Support
            const rtcSupport = window.RTCPeerConnection ? '‚úÖ Supported' : '‚ùå Not Supported';
            html += `<p><b>WebRTC Support:</b> ${rtcSupport}</p>`;
            
            // Test 2: LiveKit SDK
            const sdkLoaded = window.LiveKit ? '‚úÖ Loaded' : '‚ùå Not Loaded';
            html += `<p><b>LiveKit SDK:</b> ${sdkLoaded}</p>`;
            
            // Test 3: Get Token
            try {
                const sessionId = window.sessionId || '45'; // Use session 45 as fallback (academic session)
                const sessionType = window.sessionType || 'academic'; // Use academic as fallback
                const response = await fetch(`/api/meetings/${sessionId}/token?session_type=${sessionType}`, {
                    method: 'GET',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRF-TOKEN': document.querySelector('meta[name="csrf-token"]')?.content || ''
                    }
                });
                
                if (response.ok) {
                    const data = await response.json();
                    if (data.success && data.data?.access_token) {
                        html += `<p><b>Token Generation:</b> ‚úÖ Success</p>`;
                        html += `<p><b>Token Length:</b> ${data.data.access_token.length}</p>`;
                    } else {
                        html += `<p><b>Token Generation:</b> ‚ùå Failed - Invalid response format</p>`;
                        html += `<p><b>Response:</b> ${JSON.stringify(data)}</p>`;
                    }
                    
                    // Test 4: Connection
                    const room = new window.LiveKit.Room({
                        adaptiveStream: false,
                        dynacast: false,
                        webRtcConfig: {
                            iceServers: [
                                { urls: 'stun:stun.l.google.com:19302' }
                            ]
                        }
                    });
                    
                    try {
                        await room.connect('wss://test-rn3dlic1.livekit.cloud', data.data.access_token);
                        html += `<p><b>LiveKit Connection:</b> ‚úÖ Connected!</p>`;
                        html += `<p><b>Room:</b> ${room.name}</p>`;
                        html += `<p><b>Participant:</b> ${room.localParticipant.identity}</p>`;
                        
                        // Disconnect after success
                        room.disconnect();
                    } catch (connectError) {
                        html += `<p><b>LiveKit Connection:</b> ‚ùå Failed</p>`;
                        html += `<p><b>Error:</b> ${connectError.message}</p>`;
                        
                        // Detailed error analysis
                        if (connectError.message.includes('could not establish pc connection')) {
                            html += `<h3>üî• Diagnosis: WebRTC/Network Issue</h3>`;
                            html += `<ul>`;
                            html += `<li>Check if UDP ports 443, 50000-60000 are open</li>`;
                            html += `<li>Check firewall/antivirus settings</li>`;
                            html += `<li>Try disabling VPN if active</li>`;
                            html += `<li>Try a different network (mobile hotspot)</li>`;
                            html += `</ul>`;
                        }
                    }
                    
                } else {
                    html += `<p><b>Token Generation:</b> ‚ùå Failed (${response.status})</p>`;
                }
            } catch (error) {
                html += `<p><b>Test Error:</b> ${error.message}</p>`;
            }
            
            // Test 5: STUN Server
            try {
                const pc = new RTCPeerConnection({
                    iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
                });
                const offer = await pc.createOffer();
                await pc.setLocalDescription(offer);
                
                // Wait for ICE gathering
                await new Promise((resolve) => {
                    if (pc.iceGatheringState === 'complete') {
                        resolve();
                    } else {
                        pc.addEventListener('icegatheringstatechange', () => {
                            if (pc.iceGatheringState === 'complete') {
                                resolve();
                            }
                        });
                        setTimeout(resolve, 3000); // Timeout after 3 seconds
                    }
                });
                
                const candidates = pc.localDescription.sdp.match(/candidate:.+/g) || [];
                const hasPublicIP = candidates.some(c => !c.includes('host') && !c.includes('127.0.0.1'));
                
                if (hasPublicIP) {
                    html += `<p><b>STUN Server:</b> ‚úÖ Working (public IP obtained)</p>`;
                } else {
                    html += `<p><b>STUN Server:</b> ‚ö†Ô∏è May be blocked</p>`;
                }
                
                pc.close();
            } catch (stunError) {
                html += `<p><b>STUN Test:</b> ‚ùå Failed</p>`;
            }
            
            results.innerHTML = html;
        }
    </script>
</body>
</html>
